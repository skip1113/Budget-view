{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { invariant } from '../utils';\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty } from './utils';\nimport { parseDateTimeSkeleton } from './skeleton';\n\nfunction isNumericType(t) {\n  return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\n\n\nexport function bestFitFormatMatcherScore(options, format) {\n  var score = 0;\n\n  if (options.hour12 && !format.hour12) {\n    score -= removalPenalty;\n  } else if (!options.hour12 && format.hour12) {\n    score -= additionPenalty;\n  }\n\n  for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n    var prop = DATE_TIME_PROPS_1[_i];\n    var optionsProp = options[prop];\n    var formatProp = format[prop];\n\n    if (optionsProp === undefined && formatProp !== undefined) {\n      score -= additionPenalty;\n    } else if (optionsProp !== undefined && formatProp === undefined) {\n      score -= removalPenalty;\n    } else if (optionsProp !== formatProp) {\n      // extra penalty for numeric vs non-numeric\n      if (isNumericType(optionsProp) !== isNumericType(formatProp)) {\n        score -= differentNumericTypePenalty;\n      } else {\n        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n        var optionsPropIndex = values.indexOf(optionsProp);\n        var formatPropIndex = values.indexOf(formatProp);\n        var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n\n        if (delta === 2) {\n          score -= longMorePenalty;\n        } else if (delta === 1) {\n          score -= shortMorePenalty;\n        } else if (delta === -1) {\n          score -= shortLessPenalty;\n        } else if (delta === -2) {\n          score -= longLessPenalty;\n        }\n      }\n    }\n  }\n\n  return score;\n}\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\n\nexport function BestFitFormatMatcher(options, formats) {\n  var bestScore = -Infinity;\n  var bestFormat = formats[0];\n  invariant(Array.isArray(formats), 'formats should be a list of things');\n\n  for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n    var format = formats_1[_i];\n    var score = bestFitFormatMatcherScore(options, format);\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestFormat = format;\n    }\n  }\n\n  var skeletonFormat = __assign({}, bestFormat);\n\n  var patternFormat = parseDateTimeSkeleton(bestFormat.rawPattern); // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n  // Method adjustFieldTypes\n\n  for (var prop in patternFormat) {\n    var skeletonValue = skeletonFormat[prop];\n    var patternValue = patternFormat[prop];\n    var requestedValue = options[prop]; // Don't mess with minute/second or we can get in the situation of\n    // 7:0:0 which is weird\n\n    if (prop === 'minute' || prop === 'second') {\n      continue;\n    } // Nothing to do here\n\n\n    if (!requestedValue) {\n      continue;\n    } // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n    // Looks like we should not convert numeric to alphabetic but the other way\n    // around is ok\n\n\n    if (isNumericType(patternValue) && !isNumericType(requestedValue)) {\n      continue;\n    }\n\n    if (skeletonValue === requestedValue) {\n      continue;\n    }\n\n    patternFormat[prop] = requestedValue;\n  }\n\n  return patternFormat;\n}","map":{"version":3,"sources":["C:/Users/Skipk/du-bootcamp/budget-view/budget-view/client/node_modules/@formatjs/ecma402-abstract/lib/src/DateTimeFormat/BestFitFormatMatcher.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","invariant","DATE_TIME_PROPS","removalPenalty","additionPenalty","differentNumericTypePenalty","longMorePenalty","shortMorePenalty","shortLessPenalty","longLessPenalty","parseDateTimeSkeleton","isNumericType","bestFitFormatMatcherScore","options","format","score","hour12","_i","DATE_TIME_PROPS_1","prop","optionsProp","formatProp","undefined","values","optionsPropIndex","indexOf","formatPropIndex","delta","Math","max","min","BestFitFormatMatcher","formats","bestScore","Infinity","bestFormat","Array","isArray","formats_1","skeletonFormat","patternFormat","rawPattern","skeletonValue","patternValue","requestedValue"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { invariant } from '../utils';\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty, } from './utils';\nimport { parseDateTimeSkeleton } from './skeleton';\nfunction isNumericType(t) {\n    return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\nexport function bestFitFormatMatcherScore(options, format) {\n    var score = 0;\n    if (options.hour12 && !format.hour12) {\n        score -= removalPenalty;\n    }\n    else if (!options.hour12 && format.hour12) {\n        score -= additionPenalty;\n    }\n    for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n        var prop = DATE_TIME_PROPS_1[_i];\n        var optionsProp = options[prop];\n        var formatProp = format[prop];\n        if (optionsProp === undefined && formatProp !== undefined) {\n            score -= additionPenalty;\n        }\n        else if (optionsProp !== undefined && formatProp === undefined) {\n            score -= removalPenalty;\n        }\n        else if (optionsProp !== formatProp) {\n            // extra penalty for numeric vs non-numeric\n            if (isNumericType(optionsProp) !==\n                isNumericType(formatProp)) {\n                score -= differentNumericTypePenalty;\n            }\n            else {\n                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n                var optionsPropIndex = values.indexOf(optionsProp);\n                var formatPropIndex = values.indexOf(formatProp);\n                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n                if (delta === 2) {\n                    score -= longMorePenalty;\n                }\n                else if (delta === 1) {\n                    score -= shortMorePenalty;\n                }\n                else if (delta === -1) {\n                    score -= shortLessPenalty;\n                }\n                else if (delta === -2) {\n                    score -= longLessPenalty;\n                }\n            }\n        }\n    }\n    return score;\n}\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\nexport function BestFitFormatMatcher(options, formats) {\n    var bestScore = -Infinity;\n    var bestFormat = formats[0];\n    invariant(Array.isArray(formats), 'formats should be a list of things');\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format = formats_1[_i];\n        var score = bestFitFormatMatcherScore(options, format);\n        if (score > bestScore) {\n            bestScore = score;\n            bestFormat = format;\n        }\n    }\n    var skeletonFormat = __assign({}, bestFormat);\n    var patternFormat = parseDateTimeSkeleton(bestFormat.rawPattern);\n    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n    // Method adjustFieldTypes\n    for (var prop in patternFormat) {\n        var skeletonValue = skeletonFormat[prop];\n        var patternValue = patternFormat[prop];\n        var requestedValue = options[prop];\n        // Don't mess with minute/second or we can get in the situation of\n        // 7:0:0 which is weird\n        if (prop === 'minute' || prop === 'second') {\n            continue;\n        }\n        // Nothing to do here\n        if (!requestedValue) {\n            continue;\n        }\n        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n        // Looks like we should not convert numeric to alphabetic but the other way\n        // around is ok\n        if (isNumericType(patternValue) &&\n            !isNumericType(requestedValue)) {\n            continue;\n        }\n        if (skeletonValue === requestedValue) {\n            continue;\n        }\n        patternFormat[prop] = requestedValue;\n    }\n    return patternFormat;\n}\n"]},"metadata":{},"sourceType":"module"}